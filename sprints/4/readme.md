### 1 задача
кароче чтобы ты не сидел и не ебался как я

1) строй инвертированный индекс (можешь погуглить) вхождения всех слов в документах, а не наоборот

2) для получения позиций начала вхождения подстроки в строку используй Array.from(<тут строка>) и перебирай буквы сравнивая с подстрокой (эта операция займет O(n) и самая оптимальная

3) лучше использовать НЕПОЛНЫЙ selection sort для сортировки документов по релевантности, так как нужно получить 5 самых релевантных документов

4) инвертированный индекс строй сразу после чтения строки из файла, так быстрее

5) поиск делай тоже сразу после чтения строки и записывай результат

6) std.out делай один раз в самом конце

7) храни кэш запросов и сначала проверяй был ли такой запрос раньше, чтобы для одинаковых данных не прогонять весь цикл с поиском




## 2 задача
По второй финальной задаче с хэш таблицей

По сути она простая

задаем изначальный размер таблицы 10^6 - на меньших объемах последние тесты отваливались по таймауту при поиске

например для 10^5 время теста занимало больше 10 секунд



В качестве хэш функции достаточно делить  int(key) % <размер таблицы>



Для решения коллизий лучше использовать метод открытой аддресации, для js особенно

 
